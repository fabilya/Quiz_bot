import os.path

import whisper
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery
from thefuzz import fuzz

from admin_panel.telegram.models import TgUser
from tg_bot.db.db_commands import create_tg_user, create_question, \
    random_question, count_questions, check_answer
from tg_bot.keyboards.inline import question_kb, quiz
from tg_bot.loader import bot
from tg_bot.middlewares.blocking import BlockingMiddleware
from tg_bot.misc.utils import delete_message
from tg_bot.states.all_states import Question, Answer

start_project_router = Router()
start_project_router.message.middleware(BlockingMiddleware())
start_project_router.callback_query.middleware(BlockingMiddleware())

GREETINGS = (
    '–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n'
    '<b>–Ø –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–≤–æ–∏ –∑–Ω–∞–Ω–∏—è</b>\n'
    '–ö–∞–∫ –±—É–¥–µ—à—å –≥–æ—Ç–æ–≤, –∂–º–∏ –∫–Ω–æ–ø–∫—É "–ó–∞–ø–∏—Å–∞—Ç—å –≤–æ–ø—Ä–æ—Å"'
)

GREETINGS2 = (
    '–†–∞–¥ —Å–Ω–æ–≤–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å, {message.from_user.first_name}!\n'
)

ACCEPT_QUESTION = (
    '–¢–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏ –æ—Ç–≤–µ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω—ã!\n'
    '–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∑–Ω–∞–Ω–∏–π - –∂–º–∏ "–í–∏–∫—Ç–æ—Ä–∏–Ω–∞"\n'
    '–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë –≤–æ–ø—Ä–æ—Å—ã - –∂–º–∏ "–ó–∞–ø–∏—Å–∞—Ç—å –≤–æ–ø—Ä–æ—Å"!'
)

ANSWER_FOR_QUESTION = (
    '–¢–≤–æ–π –≤–æ–ø—Ä–æ—Å: {question}\n'
    '–û—Ç–≤–µ—á–∞–π —Å –ø–æ–º–æ—â—å—é –≤–æ–∏—Å–∞ üì¢'
)


@start_project_router.message(Command('start'))
async def command_start(message: Message, state: FSMContext, tg_user: TgUser):
    """–í–≤–æ–¥ –∫–æ–º–∞–Ω–¥—ã /start"""
    if not tg_user:
        await create_tg_user(
            user=message.from_user
        )
        await message.answer(GREETINGS.format(message=message),
                             reply_markup=question_kb())
    else:
        await message.answer(GREETINGS2.format(message=message),
                             reply_markup=quiz())
        await state.set_state(Answer.get_question)


@start_project_router.callback_query(F.data == 'question')
async def add_question(callback: CallbackQuery, state: FSMContext):
    await callback.message.delete()
    await callback.message.answer('–ù–∞–ø–∏—à–∏ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å')
    await state.set_state(Question.get_question)


@start_project_router.message(Question.get_question)
async def add_answer(message: Message, state: FSMContext):
    await state.update_data(text=message.text)
    await message.answer('–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –æ—Ç–≤–µ—Ç –Ω–∞ —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å!')
    await state.set_state(Question.get_answer)


@start_project_router.message(Question.get_answer)
async def bd_question(message: Message, state: FSMContext, tg_user: TgUser):
    await state.update_data(answer_text=message.text)
    context_data = await state.get_data()
    await create_question(
        add_question=context_data['text'],
        add_answer=context_data['answer_text'],
        user=tg_user
    )
    msg = await message.answer(ACCEPT_QUESTION, reply_markup=quiz())
    await state.clear()
    await delete_message(msg)
    await state.set_state(Answer.get_question)


@start_project_router.callback_query(Answer.get_question, F.data == 'quiz')
async def quiz_time(callback: CallbackQuery, state: FSMContext,
                    tg_user: TgUser):
    await callback.message.delete()
    questions = await count_questions(user=tg_user)
    if questions > 0:
        question = await random_question(user=tg_user)
        await state.update_data(get_question=question)
        await callback.message.answer(
            ANSWER_FOR_QUESTION.format(question=question))
        await state.set_state(Answer.get_answer)
    else:
        await callback.message.answer('–¢—ã –Ω–µ –∑–∞–ø–∏—Å–∞–ª –Ω–∏ –æ–¥–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞!',
                                      reply_markup=question_kb())


@start_project_router.message(Answer.get_answer, F.voice)
async def save_voice_as_mp3(message: Message, state: FSMContext):
    """
    –°–∫–∞—á–∏–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –µ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ mp3.
    –ü–æ—Å–ª–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∞—É–¥–∏–æ –≤ —Ç–µ–∫—Å—Ç - —É–¥–∞–ª—è–µ—Ç —Ñ–∞–π–ª.
    """
    split_tup = os.path.splitext(message.voice.file_unique_id)
    file_name = f'{split_tup[0]}_{message.from_user.full_name}.mp3'
    await bot.download(message.voice.file_id, file_name)

    model = whisper.load_model("small")
    result = model.transcribe(file_name, fp16=False, language='ru')
    await state.update_data(get_answer=result['text'])
    context_data = await state.get_data()
    get_original_answer = await check_answer(context_data['get_question'])
    if fuzz.ratio(context_data['get_answer'], get_original_answer) > 70:
        await message.answer(f'–ü–æ–∑–¥—Ä–∞–≤–ª—è—é, –æ—Ç–≤–µ—Ç: <b>{result["text"]}</b> –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π!')
    else:
        await message.answer(f'–û—Ç–≤–µ—Ç {result["text"]} –Ω–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π')
    os.remove(file_name)
